- Binary search is an alg. that runs in O(log n)
in worst case, where n is size of search space.
  - Each comparison cuts the search space in
  half, you never look at both halves - only
  one.
  - E.g.: search for 7 in a sorted elem. of 16
  elems.
    - After 1 comparison -> 8 elems. left.
    - After 2 comp. -> 4 elems.
    - After 3 comp. -> 2.
    - After 1 -> 1.
  - So it takes 4 steps, and 
  log base 2 16 = 4.
  - If a search space starts with n elems.,
  after k steps:
    - n/2^k = 1
  - Solving:
    - 2^k = n -> k = log base 2 n (drop
    base 2).
  - Binary search is O(log n) because each
  step halves remaining elems., and it takes
  log n halvings to get down to one.
- For binary search to work, search space needs
to be sorted.
- BSTs are based on binary search.

- Normally, binary search done on arr. of sorted
elems., but you can use it in more creative ways.

- If you have sorted array arr and an element x,
then in O(log n) time and O(1) space, binary
search can:
  - Find the index of x if it's in arr.
  - Find first or last index in which x can be
  inserted to maintain being sorted.

- Let's say there's a sorted int array arr, and
you know num. x is in it, but you don't know at
what index.
- You want to find pos. of x.
- Start by checking elem. in middle of arr., if
this elem. is too small, then we know every elem.
in left half will also be too small, since arr.
is sorted.
- Similarly, if elem. is too large, then every
elem. in right half also too large.

- We can discard half that can't contain x, and
then repeat process on other half.
- We continue this process of cutting arr. in 
half until we find x.

- Binary search implemention:
  1. Declare left = 0 and right = arr.len - 1,
  these vars. repr. inclusive bounds of curr.
  search space at any given time, initially
  we consider entire arr.
  2. While left <= right:
    - Calc. middle of curr. search space,
    mid = (left + right) // 2 (floor div.).
    - Check arr[mid], 3 possibilities:
      - If arr[mid] = x, elem. found.
      - If arr[mid] > x or arr[mid] < x,
      halve search space by either doing
      right = mid - 1 or left = mid + 1.
  3. If you get to this point without
  arr[mid] = x, then search unsuccessful,
  left pointer will be at index where x
  would need to be inserted to maintain
  arr being sorted.

- Because search space is halved every iter.,
binary search's worst case time compl. is
O(log n) (makes it powerful as log. time is
much faster compared to linear time).

****************
Duplicate elems.
****************

- If your input has duplicates, you can modify
binary search templ. to find either first or
last pos. of a given elem.
- If target appears multip. times, then following
template will find left most index:
  - def binary_search(arr, target):
        left = 0
        right = len(arr)
        while left < right:
            mid = (left + right) // 2
            if arr[mid] >= target:
                right = mid
            else:
                left = mid + 1

        return left
- Following template will find right most 
insertion point (index of right-most elem. + 1):
  - def binary_search(arr, target):
        left = 0
        right = len(arr)
        while left < right:
            mid = (left + right) // 2
            if arr[mid] > target:
                right = mid
            else:
                left = mid + 1

        return left
  - Left most index template finds left most because
  when arr[mid] == target, you don't stop.
  - You shrink right boundary to keep searching left.
  - This keeps earlier duplicates in play.
  - E.g. arr: [1, 2, 2, 2, 3], target = 2.
    - Search narrows toward first 2.