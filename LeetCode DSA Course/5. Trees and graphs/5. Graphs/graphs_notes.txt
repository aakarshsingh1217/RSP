*******************************************
How are graphs given in algorithm problems?
*******************************************

----------------------------------
First input format: array of edges
----------------------------------

- Input will be a 2D array.
- Each elem. of the arr. will be in the form [x, y] which
indicates there's an edge b/w. x and y.
- The prob. may have a story for these edges - using
cities e.g., story would be something like "[x, y] means
there's a highway connecting city x and city y".

- Edges count be dir. or undir., info. will be in prob.
descr.

- Why can't we immediately start traversal?
- Let's say we want to start DFS from node 0 (sometimes
prob. will state which node you should start from,
sometimes you need to figure it out).
- When we're at node 0, how do we find neighbours?
  - We'd need to iterate over entire input to find all
  edges that incl. 0.
  - When we move to a neighbour node, need to iter. over
  entire input again to find all neighbours of that node.

- At every node, we'd need to iter. over entire input to
find neighbours, this's very slow!

- Before starting traversal, can pre - process input so 
we can easily find all neighbours of any given node.
- Ideally, want to use a DS where you can give node as
an arg. and be returned a list of neighbours.
- Easiest way to do this is using a hashmap.

- Use hashmap graph that mapped ints. to lists of ints.
- We can iter. over the input and for each [x, y] pair,
can put y in the list assoc. with graph[x].
- If edges undir., we'll also need to put x in list
assoc. with graph[y].
- After building this hashmap, we can do graph[0] and
have all neighbours of node 0.

-     2
   ↙  ↑  ↘
  0  → 1   3
  - This graph can be repr. by an arr. of dir. edges:
    - edges = [[0, 1], [1, 2], [2, 0], [2, 3]].
      - Graph only exists as idea derived from arr.

-----------------------------------
Second input format: adjacency list
-----------------------------------

- In an adj. list, nodes numbered from 0 to n - 1.
- Input will be a 2D int. arr., e.g. called graph.
- graph[i] will be list of all outgoing edges from
ith node.

-     2
   ↙  ↑  ↘
  0  → 1   3
  - Above graph can be repr. by adj. list
  graph = [[1], [2], [0, 3], []].

- With this input, can already access all neighbours
of any given node.
- We don't need to do any pre-processing!
- This makes adj. list most convenient format.
- If we want all neighbours of node 6, we just check
graph[6].

------------------------------------
Third input format: adjacency matrix
------------------------------------

- Nodes will be numbered from 0 to n - 1.
- You'll be given a 2D matrix of size n * n, e.g.
called graph.
- if graph[i][j] == 1, means there's an outgoing edge
from node i to node j.
- E.g.:
  -     2
     ↙  ↑  ↘
    0  → 1   3
    - Has adj. matrix: [
                  [0, 1, 0, 0],
                  [0, 0, 1, 0],
                  [1, 0, 0, 1],
                  [0, 0, 0, 0]
                       ].

- 2 options when given this format.
- During traversal, at any given node you can iter.
over graph[node], and if graph[node][i] == 1, you
know node i is a neighbour.
- You can also pre-process graph as we did with
arr. of edges.
- Build a hashmap and then iter. over entire graph,
if graph[i][j] == 1, then put j in list assoc.
with graph[i].
- This way, when performing traversal, you won't 
need to iterate n times at every node to find
neighbours.
- This's useful when nodes only have a few
neighbours and n is large.

- Both these approaches have time compl. O(n^2).

-------------------------
Last input format: matrix
-------------------------

- Input will be a 2D matrix and prob. descr. story.
- Each square repr. something, and squares connected
in some way.
- E.g., "each square of the matrix is a village,
villages trade with neighbouring villages, which are
directly above, to left, to right or below them".

- In this case, each square (row, col) of the matrix
is a node, and neighbours are (row - 1, col),
(row, col - 1), (row + 1, col), (row, col + 1).

- Unlike other input formats, nodes in these graphs
are not numbered 0 until n.
- Instead, each elem. in the matrix repr. a node,
edges are determined by prob. descr., not the inpt.
- In the e.g. given above, the prob. descr.
states that villages trade with those directly adj.
to them.
- Thus, edges are those within 1 square.

*****************************************
Code differences between graphs and trees
*****************************************

- While binary tree has a root node to start
traversal from, a graph doesn't always have an
obvious start point.

- In a graph, might need to convert input into
a hashmap first.
- When traversing a tree, we refer to node.left and
node.right at each node.
- When traversing a graph, we'll need to use a for
loop to iter. over the neighbours of the curr.
node, since node could have any num. neighbours.

- Implementation of DFS for graphs includes doing it
recursively and following the same format:
  - Check for base case.
  - Recursively call on all neighbours.
  - Do some logic to calc. the answer.
  - Return answer.

- In any undir. graph or a directed graph with cycles,
implementing DFS the same way as a binary tree DFS
will result in an infinite cycle (remember LL cycles?,
imagine your code walks in a circle forever!).
- Like with trees, in most graph questions, we only need
to (and want to) visit each node once.
- To prevent cycles and unecessarily visiting a node
more than once, we can use a set seen.
- Before we visit a node, we first check if node's in
seen.
- If it isn't, we add it to seen before visiting it.
- This allows us to only visit each node once in
O(1) time because adding and checking for existence
in a set takes constant time.

- In trees, you start at root and edges only move
down - once we left a node, no way to get back to it.
- With graphs, you could have rel. A <-> B and move
b/w. A and B forever.