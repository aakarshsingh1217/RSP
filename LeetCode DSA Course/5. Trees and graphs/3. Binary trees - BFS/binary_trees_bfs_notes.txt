***********************
When to use BFS vs DFS?
***********************

- May be asked some trivia regarding BFS vs DFS, such as their
drawbacks.
- Main disadvantage of DFS is that you could end up wasting a
lot of time looking for a val.
- Let's say you had a huge tree and you were looking for a val.
stored in the root's right child.
  - If you do DFS prioritizing left before right, then you'll
  search entire left subtree, which could be hundreds of
  thousands/millions of opers.
  - Meanwhile, node's literally one oper. away from root.
- Main disadvantage of BFS is that if node you're searching for
is near bottom, then you'll waste alot of time searching through
all levels to reach bottom.

- In terms of space compl., DFS uses space linear w/ height of tree
(max depth), whereas BFS uses space linear with level that has most
nodes.
- In some cases, DFS uses less space, in others BFS uses less.

- E.g., in a perfect binary tree, DFS uses O(log n) space, whereas
BFS uses O(n).
- Final level in a perfect binary tree has n/2 nodes, but tree only
has depth log n.
  - Has n/2 nodes because a perfect binary tree has:
    - Every internal node with exactly 2 children.
    - All leaves at same depth.
    - Height = h (root at level 0).
  - Nodes at level i = 2^i, so:
    - level 0: 1
      level 1: 2
      level 2: 4
      .
      .
      .
      level h: 2^h <- last level.
  - Total num. nodes is sum of geom series:
    - n = 1 + 2 + 4 + ... + 2^h = 2^(h+1) - 1.
    - Solve for last level size:
      - 2^h = (n + 1)/2 (after rearranging geom. series sum formula).

- However, if you had lopsided tree (e.g. straight line), BFS will
have O(1) space compl. while DFS will have O(n) (but lopsided tree
edge case whereas more full tree is expectation).

------------------------
BFS code implementations
------------------------

- W/ an efficient queue, dequeue and enqueue opers. are O(1) which
means time compl. of BFS same as DFS.
- We visit each node only once, so time compl. is O(n * k), where 
n total num. nodes and k is amount work done at each node, usually
O(1).

*******************************************
Example 1: 199. Binary Tree Right Side View
*******************************************

- Time and space compl. of O(n) for same reasons as algs. in
prev. article (visit each node only once and perf. a constant amt.
work each node, queue can hold up to O(n) nodes).

*********************************************
103. Binary Tree Zigzag Level Order Traversal
*********************************************

- Time compl. Θ(n) (tight bound):
  - Each node dequeued once.
  - Each node's val appended once.
  - Reverse list on every odd level.
  - Cost of reversals:
    - Total elems. reversed across all levels = n.
    - Each node participats in at most one reverse.
  - So total reversal cost is: ∑ level sizes = n.
  - Total: Θ(n).
- Space complexity Θ(n) (tight bound):
  - Let w be max. width of tree.
  - BFS queue can hold up to w nodes.
  - In a perfect binary tree, w = Θ(n).
  - Output stores all n vals.
  - Total space: Θ(n).