- Heap's a ds. that's an implement. of the priority queue.

- Prio. queue is an ADT, heap's one of many ways to implement
a prio. queue, however people use term interchangeably.

- Heap's a container that stores elems., and supports the following
opers.:
  - Add an elem. in O(log n).
  - Remove min. elem. in O(log n).
  - Find min. elem. in O(1).

- A heap can also find max elems. instead of min elems.
- If a heap is configured to find/remove the min elem., it's called
a min heap, otherwise to find/remove max elem. is a max heap.

- Ability to find the max/min elem. in constant time, while only
needing logarithmic time to maintain this ability through changes

**************************
How is a heap implemented?
**************************

- There're multiple ways to implem. a heap, although most popular
way is called a binary heap using an arr.

- A binary heap implements a binary tree, but with only an array.
- Idea is that each elem. in the arr. is a node in the tree.
- Smallest elem. in tree is the root, and following prop.
maintained at every node: if A is parent of B, then A.val <= B.val.
- Notice this property directly implies that root is smallest 
elem.

- Another constraint is tree must be a complete tree.

- Parent child rels. are done using math with indices.
- First elem. at index 0 is root, then elems. at indices 1 and 2
are root's children, the elems. at indices 3 and 4 are children of
elem. at index 1 and elems. at indices 5 and 6 are children of elem.
at index 2, and so on.
- If a node is at index i, then its children are at indices
2i + 1 and 2i + 2.
- When elems. added/removed, opers. are done to maintain
aformentioned prop. of parent.val <= child.val.
- Num. opers. needed scales logarithmically with num. elems. in
heap, and process is known as "bubbling up".

- An existing arr. of elems. can also be converted into a heap in
linear time, although process is complicated.

- In many probs., using a heap can improve algs. time compl. from
O(n^2) to O(n * log n), which is a massive improvement (for 
n = 1,000,000, this is 50,000 times faster).
- A heap's a great option whenever you need to find the max. or 
min. of something repeatedly.

- Python implems. min heap by default.
- If you're dealing with nums. and want to deal with opposite
type of heap that your lang. implements, an easy way to do
this is multiply all nums. by -1.

**********************************
Example 1: 1046. Last Stone Weight
**********************************

- Converting arr. into heap takes O(N) time.
- On each smash, at least one rock destroyed, so at most n iters.
- At each iter., we perform pops and pushes on heap, which has len.
n at start, which gives us time compl. O(n * log n).
- Heap uses O(n) space (heapify list input).

******************************************************
Example 2: 2208. Minimum Operations to Halve Array Sum
******************************************************

- Each loop iter. takes O(log n) time for heap opers.
- Number of opers. needed is linear with n.
- While may be thinking, if we have huge num, it would need
to be halved many times, but each oper. on it would also reduce
sum by large amt.
- Therefore time compl. O(n * log n).
- A more clear arg. as to why num. opers. bounded by n - you
could always just perf. oper. on each num. once.
- Extra:
  - Inside for loop you do:
    - heappop(nums) # O(log n).
    - heappush(nums) # O(log n).
    - Everything else O(1).
    - So one iter. = O(log n).
  - How many iters. can loop run?
    - You stop when sums halved.
    - Always halve largest num.
    - Halving large num. makes big progress.
    - Once numbers small, halving them barely helps.
    - Only need about one meaningful oper. per og. elem. to
    lose half the pile.
    - So: total num. opers. scales with how many elems.
    you started with -> n.

********************************************
Example 3: 295. Find Median from Data Stream
********************************************

- Alg. allows us to have an O(1) time compl. for findMedian and an
O(log n) time compl. for addNum, which makes it incredibly fast
alg., where n is no. times addNum called so far.
- Space compl. is O(n) to store heaps.

*****************************************
1962. Remove Stones to Minimize the Total
*****************************************

- Given n as piles.length:
  - Time compl. - O(n + k * log n):
    - An arr. can be converted to a heap in linear time (O(n))
    using a method like heapify().
    - After converting input to a heap, we perf. k heap opers.
    - Each heap oper. costs O(log n), which gives us time
    compl. O(n + k * log n)
  - Space compl. - O(n):
    - Heap's length equal to n, which is all extra space we use.