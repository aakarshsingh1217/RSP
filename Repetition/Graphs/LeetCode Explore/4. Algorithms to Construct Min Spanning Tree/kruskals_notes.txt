1. Ascending Sort all edges by their weight.
2. Add edges in that order into MST. Skip edges that would prod.
cycles in MST.
3. Repeat step 2 until N - 1 edges added.

- E.g. graph:
          (0.5)
      A -------- B
      | \        | \
   (1)|  \(1.5)  |  \(4)
      |     \ _  |(3) C
      E -------- D
         (2)  

*********************************
Why can we apply greedy strategy?
*********************************

- Greedy alg.: add edges with least weight and not creating any
cycle.
- Main idea of Kruskal's: among all edges that don't create
cycles, pick edge with least weight.

*******************
Complexity Analysis
*******************

- Time compl.: O(e * log e) where e repr. num edges.
  - First we need to sort all edges of graph in ascending order,
  takes O(e log e) time.
  - Next, start building MST by selecting which edges should
  be included. For each edge, look at whether both vertices
  of edge belong to same connected component; which is an
  O(a(V)) oper., where a refers to inverse ackermann func. in
  worst case, tree will not be complete until we reach very
  last edge (edge with largest weight) so process takes
  O(E * a(V)) time.
  - Therefore total time compl. is O(e log e + e * a(v)) =
  O(e log e).
- Space compl.: O(V) where V repr. num. vertices.
  - Keeping track of root of every vert. in UF reqs. O(V)
  space.
  - Sorting alg. Timsort in python uses O(E) space in worst case.