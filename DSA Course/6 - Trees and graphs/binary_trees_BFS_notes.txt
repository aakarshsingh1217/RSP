- In breadth-first search (BFS), we prioritize breadth.
- A node's depth is its distance from root.
- In DFS, we always go down as far as we could, incr.
depth of curr. node until we reached a leaf.

- In BFS, we traverse all nodes at a given depth before
moving onto next depth.
- So if you performed BFS on a large complete binary tree,
depth of nodes traversed may look like 0, 1, 1, 2, 2, ...

- A complete binary tree is one where every level (except
possibly the last) is full, and all nodes in the last level
are as left as possible.

- Can think of each depth of a tree as a "level", as if tree
was a building with root being top floor and edges were
staircases down to a lower floor.
- E.g. tree:
  -    0     | Depth = 0
       /\    |
      1  2   | Depth = 1
     /\   \  |
    3  4   5 | Depth = 2
        \    |
         6   | Depth = 3

- A BFS performed on above tree would visit nodes in same
order as their vals.
- We visit all nodes at a depth d before visiting any node
at a depth of d + 1.

- While DFS was implemented using a stack (recursion uses
a stack under the hood), BFS is implemented iteratively 
with a queue.
- You can implement BFS with recursion, but wouldn't make
much sense as it's a lot more difficult without any benefit.

**********************
When to use BFS vs DFS
**********************

- Mentioned prev. that it doesn't matter if you choose pre/
in/post order DFS, important thing is that you visit all
nodes.
- If problem just reqs. you to visit all nodes, then it
doesn't matter if you use BFS either, because every "visit"
to a node will store sufficient info. irrespective of visit
order.

- It's rare to find a problem where using DFS is "better"
than using BFS.
- However, implementing DFS usually quicker because it 
requires less code, and is easier to implem. if using 
recursion.

- There're quite a few probs. where using BFS makes more
sense algorithmically than DFS.
- Usually applies to any prob. where we want to handle
nodes according to their level.

- Main disadvantage of DFS is that you could end up wasting
alot of time looking for a val.
- Let's say you had a huge tree, and you were looking for a
val. stored in the root's right child. If you do DFS prioing.
left before right, you'll search the entire left subtree,
which could be millions of opers.
- Meanwhile, node is literally one oper. away from root.
- Main disadvantage of BFS is that if node you're searching
for is near bottom, then you'll waste alot of time searching
through all levels to reach bottom.

- DFS uses space linear with height of tree (max. depth) &
BFS uses space linear with the level that has the most
nodes.
  - BFS explores tree level by level using a queue.
  - At any moment, queue holds all nodes of curr. level
  (and sometimes next level) before they're processed.
  - How to derive:
    - Max. space used by BFS equals max. num. nodes stored
    in a queue at once, which occurs at widest level of
    tree.
    - E.g. tree:
      -         A
              /   \
             B     C
            / \   / \
           D  E  F   G
        - Level sizes: 1, 2, 4.
        - When processing level 2, queue holds nodes D, E,
        F, G.
        - Max queue size = 4/
      - So:
        - BFS space = O(width) (max nodes at any level).
        - For a complete binary tree, width approx. (n/2)
        = O(n).
          - Width is approx. n/2 bc. of how nodes are distr.
          across levels in a complete binary tree.
          - | Level          | # of nodes |
            -----------      |------------|
            | 0 (root)       | 1          |
            | 2              | 2          |
            | 1              | 4          |
            | ...            | ...        |
            | h (last level) | 2^h        |
            -------------------------------
          - Total num. of nodes in a compl. binary tree of
          height h is: n = 1 + 2 + 4 + ... + 2^h
                         = 2^(h + 1) - 1
          - Widest level has 2^h.
          - Now relate width to n:
            - 2^h = 2^(h+1) / 2 which is approx. (n + 1) / 2
            - So width is approx. n / 2

- In some cases, DFS uses less space, in others, BFS does.

- E.g., in a perfect binary tree, DFS uses O(log n) space,
whereas BFS uses O(n).
- Final level in a perfect binary tree has (n / 2) nodes,
but tree only has a depth of log n.
  - In BFS, nodes visited level by level and stored in queue.
  - Queue most hold all nodes in a level at same time.
  - E.g.: 
    -         A
            /   \
           B     C
          / \   / \
         D  E  F   G
    - Total nodes: n = 7.
    - Depth: log base 2 n = 3.
    - Last level nodes: 4 = n / 2.
  - When BFS reachest last level, queue contains all D, E, F 
  and G at once.
  - In perfect binary tree, level k has 2^k nodes.
  - Total nodes: n = 2^(h + 1).
  - Last level size: 2^h which is approx. n / 2.
  - So max queue size is proportional to n.
    - BFS space = O(max level width) = O(n).
    - BFS needs O(n) space because it must store an entire (widest) 
    level of the tree at once, and in a perfect binary tree that 
    level contains about half the nodes.

- However, if you have a lopsided tree (straight line) then BFS has
O(1) space complexity while DFS has O(n).

************************
BFS code implementations
************************

from collections import deque

def print_all_nodes(root):
    queue = deque([root])
    while queue:
        nodes_in_current_level = len(queue)
        # do some logic here for the current level

        for _ in range(nodes_in_current_level):
            node = queue.popleft()
            
            # do some logic here on the current node
            print(node.val)

            # put the next level onto the queue
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

- At start of each iteration inside while loop (where comment "do
some logic here for curr level" is), the queue contains exactly
all the nodes for the curr. level.
- In the beginning, that's just the root.

- We then use a for loop to iterate over curr. level.
- We store num. of nodes in curr. level nodes_in_current_level b4
iterating to make sure for loop doesn't iterate over any other
nodes.
- The for loop visits each node in curr. level and puts all
children (next level's nodes) in queue.

- Because we're removing from left and adding on the right (opp.
ends), after the for loop finishes, the queue holds all nodes
in next level.
- We move to the next while loop iter. and process repeats.

- With an efficient queue, dequeue and enqueue opers. are O(1), 
which means time compl. of BFS is same as DFS.
- Main idea is we visit each node only once, so time compl. is
O(n * k), where n is total number of nodes, and k is amount of 
work we do at each node, usually O(1).